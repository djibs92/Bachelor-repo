â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    PITCH PRÃ‰SENTATION - DIAGRAMME DE BASE DE DONNÃ‰ES
                              CloudDiagnoze - ModÃ¨le de DonnÃ©es
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Œ CONTEXTE (15 secondes)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"Maintenant, parlons de la base de donnÃ©es.

Si le diagramme de classes montre COMMENT le code est organisÃ©,
le diagramme de base de donnÃ©es montre OÃ™ les donnÃ©es sont stockÃ©es.

C'est la mÃ©moire de CloudDiagnoze : tout ce qu'on scanne doit Ãªtre persistÃ©
quelque part pour qu'on puisse le consulter, l'analyser, et l'exporter plus tard."


ğŸ¯ VUE D'ENSEMBLE (30 secondes)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

[Montrer le diagramme complet]

"Ce diagramme montre 11 tables organisÃ©es en 3 zones logiques :

ğŸ”µ ZONE BLEUE (gauche) : La gestion des utilisateurs
   â†’ users : qui utilise l'application

ğŸŸ¢ ZONE VERTE (centre) : Le moteur de scan
   â†’ scan_runs : les scans effectuÃ©s (comme des 'tickets de caisse')

ğŸŸ  ZONE ORANGE (droite) : Le stockage des ressources
   â†’ 4 tables de ressources (EC2, S3, VPC, RDS)
   â†’ 4 tables de performance (mÃ©triques techniques)

Et tout est reliÃ© par des flÃ¨ches : les clÃ©s Ã©trangÃ¨res qui garantissent
l'intÃ©gritÃ© des donnÃ©es."


ğŸ‘¤ ZONE 1 : LA TABLE USERS (30 secondes)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

[Pointer la table users en haut Ã  gauche]

"CommenÃ§ons simple : la table users.

C'est la table des comptes utilisateurs qui se connectent Ã  CloudDiagnoze.

Champs importants :

ğŸ“§ email : l'identifiant unique (pas de doublons possibles)
ğŸ”’ password_hash : le mot de passe chiffrÃ© avec bcrypt (jamais en clair !)
ğŸ¢ company_name : l'entreprise de l'utilisateur
ğŸ”‘ role_arn : le rÃ´le AWS que l'utilisateur utilise pour scanner ses ressources

ğŸ‘‰ Pourquoi c'est important ?

   CloudDiagnoze est multi-tenant. Ã‡a veut dire que si 50 entreprises utilisent
   l'application, chacune voit uniquement SES donnÃ©es.

   Comment ? GrÃ¢ce Ã  user_id : toutes les autres tables ont une colonne user_id
   qui fait rÃ©fÃ©rence Ã  cette table.

   RÃ©sultat : isolation totale. Impossible qu'une entreprise voie les donnÃ©es
   d'une autre."


ğŸ« ZONE 2 : LA TABLE SCAN_RUNS (1 minute)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

[Pointer la table scan_runs au centre]

"Maintenant, la table centrale : scan_runs.

Pensez Ã  elle comme un TICKET DE CAISSE dans un supermarchÃ©.

Quand vous scannez des ressources AWS, vous crÃ©ez un 'scan run' qui enregistre :

ğŸ†” id : un numÃ©ro unique pour ce scan
ğŸ‘¤ user_id : qui a lancÃ© ce scan ? (clÃ© Ã©trangÃ¨re vers users)
ğŸ“¦ service_type : qu'est-ce qu'on a scannÃ© ? EC2, S3, VPC ou RDS
ğŸ“… scan_timestamp : quand le scan a Ã©tÃ© fait
âœ… status : success, error, ou in_progress
ğŸ“Š total_resources : combien de ressources ont Ã©tÃ© trouvÃ©es

ğŸ‘‰ Exemple concret :

   Je lance un scan EC2 le 15 novembre 2024 Ã  10h30.

   Un scan_run est crÃ©Ã© :
   - id: 42
   - user_id: 5 (moi)
   - service_type: 'ec2'
   - scan_timestamp: 2024-11-15 10:30:00
   - status: 'success'
   - total_resources: 12

   Et les 12 instances EC2 trouvÃ©es vont pointer vers ce scan_run (scan_run_id: 42).

C'est comme Ã§a qu'on peut dire : 'Montre-moi toutes les ressources trouvÃ©es
lors du scan #42 le 15 novembre'."


ğŸ“¦ ZONE 3 : LES TABLES DE RESSOURCES (1 minute 30)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

[Pointer les 4 tables orange Ã  droite : ec2_instances, s3_buckets, vpc_instances, rds_instances]

"Maintenant, les vraies donnÃ©es : les ressources scannÃ©es.

On a 4 tables, une par service AWS :

ğŸŸ¢ ec2_instances (machines virtuelles)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Pour chaque instance EC2, on stocke :
   - instance_id : l'ID AWS (i-0123456789abc)
   - instance_type : le type de machine (t2.micro, t3.large...)
   - state : running, stopped, terminated
   - region : eu-west-1, us-east-1...
   - public_ip / private_ip : ses adresses rÃ©seau
   - tags : les tags AWS (format JSON pour Ãªtre flexible)

ğŸ‘‰ Pourquoi JSON pour tags ?
   Parce que chaque instance peut avoir 0, 5 ou 20 tags diffÃ©rents.
   PlutÃ´t que de crÃ©er 20 colonnes, on stocke Ã§a en JSON. Flexible et efficace.


ğŸŸ¡ s3_buckets (stockage de fichiers)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Pour chaque bucket S3 :
   - bucket_name : le nom unique du bucket
   - region : oÃ¹ il est hÃ©bergÃ©
   - is_public : CRITIQUE - est-il accessible publiquement ? (risque sÃ©curitÃ©)
   - is_encrypted : les donnÃ©es sont-elles chiffrÃ©es ?
   - versioning_enabled : est-ce qu'on garde l'historique des fichiers ?
   - total_size_gb : combien d'espace il occupe (pour estimer les coÃ»ts)

ğŸ‘‰ Cas d'usage rÃ©el :
   Le client peut dire : "Montre-moi tous mes buckets publics non chiffrÃ©s"
   â†’ Alerte sÃ©curitÃ© !


ğŸŸ£ vpc_instances (rÃ©seaux virtuels)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Pour chaque VPC :
   - vpc_id : l'ID du rÃ©seau
   - cidr_block : la plage d'adresses IP (ex: 10.0.0.0/16)
   - is_default : est-ce le VPC par dÃ©faut AWS ?
   - subnet_count : combien de sous-rÃ©seaux ?


ğŸŸ  rds_instances (bases de donnÃ©es)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Pour chaque base de donnÃ©es RDS :
   - db_identifier : le nom de l'instance
   - engine : PostgreSQL, MySQL, MariaDB...
   - engine_version : la version (ex: PostgreSQL 14.2)
   - storage_gb : combien d'espace disque
   - is_public : accessible depuis internet ? (risque sÃ©curitÃ©)
   - backup_retention_days : combien de jours de backup


ğŸ‘‰ Point commun de ces 4 tables :

   Elles ont TOUTES :
   - scan_run_id : vers quel scan elles appartiennent
   - client_id : l'ID de l'entreprise cliente
   - scan_timestamp : quand elles ont Ã©tÃ© scannÃ©es

   Ã‡a permet de tracer l'historique : 'Cette instance EC2 a Ã©tÃ© vue pour la
   premiÃ¨re fois le 1er novembre, puis rescannÃ©e le 15 novembre'."


ğŸ“Š LES TABLES DE PERFORMANCE (45 secondes)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

[Pointer les 4 tables de performance : ec2_performance, s3_performance, vpc_performance, rds_performance]

"Ces tables stockent les MÃ‰TRIQUES de performance.

Pourquoi sÃ©parÃ©es ? Parce qu'une ressource a des infos statiques (son ID, son type)
et des mÃ©triques dynamiques qui changent tout le temps.

Exemple avec EC2 :

ğŸ“ˆ ec2_performance stocke :
   - cpu_utilization : 23.5% (le CPU utilisÃ©)
   - network_in : 1024000 bytes (trafic rÃ©seau entrant)
   - network_out : 512000 bytes (trafic rÃ©seau sortant)
   - timestamp : quand la mÃ©trique a Ã©tÃ© prise

ğŸ‘‰ Relation : ec2_performance.ec2_instance_id â†’ ec2_instances.id

   RÃ©sultat : pour chaque instance EC2, je peux avoir 10, 100 ou 1000 points
   de performance dans le temps.

   Ã‡a permet de faire des GRAPHIQUES d'Ã©volution :
   'Montre-moi l'utilisation CPU de cette instance sur les 7 derniers jours'

Idem pour S3 (nombre de requÃªtes), VPC (trafic rÃ©seau), RDS (connexions actives)."


ğŸ”— LES RELATIONS ET CLÃ‰S Ã‰TRANGÃˆRES (45 secondes)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

[Pointer les flÃ¨ches entre les tables]

"Regardez les flÃ¨ches : ce sont les FOREIGN KEYS (clÃ©s Ã©trangÃ¨res).

Elles garantissent l'intÃ©gritÃ© des donnÃ©es.

Exemple :

users (1) â”€â”€â†’ (N) scan_runs
   Un utilisateur peut avoir plusieurs scans

scan_runs (1) â”€â”€â†’ (N) ec2_instances
   Un scan peut trouver plusieurs instances EC2

ec2_instances (1) â”€â”€â†’ (N) ec2_performance
   Une instance EC2 peut avoir plusieurs points de performance


ğŸ‘‰ Et la magie : CASCADE DELETE

   Si je supprime un scan_run, TOUTES les ressources liÃ©es sont supprimÃ©es aussi.

   Pourquoi ? Pour Ã©viter les 'orphelins' dans la base :

   âŒ SANS cascade : Je supprime le scan #42, mais les 12 instances EC2 restent
                     et pointent vers un scan qui n'existe plus â†’ incohÃ©rence

   âœ… AVEC cascade : Je supprime le scan #42, et les 12 instances EC2 sont
                     automatiquement supprimÃ©es â†’ base propre

C'est une rÃ¨gle de qualitÃ© dans la conception de bases de donnÃ©es."


ğŸ—ï¸ NORMALISATION ET BONNES PRATIQUES (45 secondes)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"Cette base de donnÃ©es respecte la 3Ã¨me Forme Normale (3NF).

En franÃ§ais, Ã§a veut dire :

âœ… Pas de redondance : chaque info n'est stockÃ©e qu'une seule fois
âœ… Pas de dÃ©pendances transitives : chaque colonne dÃ©pend uniquement de la clÃ© primaire
âœ… IntÃ©gritÃ© rÃ©fÃ©rentielle : les clÃ©s Ã©trangÃ¨res garantissent la cohÃ©rence

Exemples de bonnes pratiques appliquÃ©es :

ğŸ”¹ ClÃ©s primaires auto-incrÃ©mentÃ©es (id) sur toutes les tables
ğŸ”¹ Index sur les colonnes frÃ©quemment recherchÃ©es (user_id, scan_run_id)
ğŸ”¹ Contraintes NOT NULL sur les champs critiques (email, instance_id)
ğŸ”¹ Types de donnÃ©es appropriÃ©s (DECIMAL pour les mÃ©triques, JSON pour les tags)
ğŸ”¹ Timestamps partout pour tracer l'historique

ğŸ‘‰ RÃ©sultat : une base performante, maintenable et Ã©volutive."


ğŸ’¾ TECHNOLOGIE ET JUSTIFICATION (30 secondes)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"J'ai choisi MariaDB 11.2 pour ce projet.

Pourquoi MariaDB et pas PostgreSQL ou MySQL ?

âœ… Open source et gratuit
âœ… Compatible MySQL (Ã©norme communautÃ© et documentation)
âœ… Performances excellentes pour les lectures/Ã©critures intensives
âœ… Support natif du JSON (pratique pour les tags et mÃ©tadatas)
âœ… Outils de rÃ©plication et backup matures

Et surtout : c'est ce que j'ai utilisÃ© en entreprise, donc je maÃ®trise.

ğŸ‘‰ En production, on pourrait migrer vers PostgreSQL si besoin (pour les
   fonctionnalitÃ©s avancÃ©es comme les JSONB ou les index GIN), mais MariaDB
   est largement suffisant pour les besoins actuels."


ğŸ” SÃ‰CURITÃ‰ ET ISOLATION (45 secondes)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"Parlons SÃ‰CURITÃ‰, parce que c'est critique quand on manipule des donnÃ©es cloud.

ğŸ”’ Isolation multi-tenant :
   â†’ Chaque requÃªte SQL filtre par user_id
   â†’ Impossible qu'un utilisateur voie les donnÃ©es d'un autre

   Exemple de requÃªte :
   SELECT * FROM ec2_instances
   WHERE scan_run_id IN (SELECT id FROM scan_runs WHERE user_id = {current_user})

ğŸ”’ Mots de passe :
   â†’ Jamais stockÃ©s en clair
   â†’ HashÃ©s avec bcrypt (algorithme industriel)
   â†’ SalÃ©s automatiquement (chaque hash est unique)

ğŸ”’ AccÃ¨s Ã  la base :
   â†’ Credentials dans des variables d'environnement (.env)
   â†’ Pas de hardcoding dans le code
   â†’ Connexions via ORM (SQLAlchemy) = protection contre les injections SQL

ğŸ”’ Backup :
   â†’ StratÃ©gie de backup Ã  dÃ©finir selon l'environnement
   â†’ En dev : volume Docker persistant
   â†’ En prod : backup quotidien + rÃ©plication sur 2 AZ minimum"


ğŸ“ˆ VOLUMÃ‰TRIE ET SCALABILITÃ‰ (30 secondes)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"Question importante : est-ce que cette base peut tenir la charge ?

ScÃ©nario rÃ©aliste :

ğŸ‘¤ 100 entreprises clientes
ğŸ”„ Chacune scanne 4 services (EC2, S3, VPC, RDS) une fois par jour
ğŸ“¦ En moyenne 50 ressources par service

Calcul :
   100 clients Ã— 4 services Ã— 50 ressources Ã— 365 jours = 7,3 millions de lignes/an

ğŸ‘‰ MariaDB gÃ¨re facilement des tables de plusieurs dizaines de millions de lignes
   avec des index bien placÃ©s.

Et si Ã§a devient trop gros ? On peut :
   - Partitionner les tables par date (garder 6 mois en ligne, archiver le reste)
   - Passer sur un cluster MariaDB rÃ©pliquÃ©
   - Migrer vers une base orientÃ©e time-series (TimescaleDB) pour les perfs"


ğŸ¬ CONCLUSION (30 secondes)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"En rÃ©sumÃ©, cette base de donnÃ©es est conÃ§ue pour :

âœ… ISOLER les donnÃ©es entre clients (multi-tenant)
âœ… TRACER l'historique des scans dans le temps
âœ… SÃ‰PARER les donnÃ©es statiques (ressources) des mÃ©triques (performance)
âœ… GARANTIR l'intÃ©gritÃ© avec les clÃ©s Ã©trangÃ¨res et CASCADE DELETE
âœ… SCALER sans problÃ¨me jusqu'Ã  plusieurs millions de lignes

C'est une base NORMALISÃ‰E, SÃ‰CURISÃ‰E, et Ã‰VOLUTIVE.

Et surtout : elle s'intÃ¨gre parfaitement avec le diagramme de classes qu'on a vu
avant. L'ORM SQLAlchemy fait le pont entre les deux."


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                CONSEILS PRÃ‰SENTATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ’¬ LANGAGE CORPOREL
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â†’ POINTER les tables dont tu parles
â†’ TRACER les flÃ¨ches (relations) avec ton doigt pour montrer le flux
â†’ Faire des CERCLES autour des zones logiques (users, scan_runs, ressources)
â†’ Utiliser une FEUILLE pour masquer certaines parties et rÃ©vÃ©ler progressivement


ğŸ“Š SLIDES / SUPPORT VISUEL
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â†’ Slide 1 : Diagramme complet avec les 3 zones colorÃ©es
â†’ Slide 2 : Zoom sur users (zone bleue)
â†’ Slide 3 : Zoom sur scan_runs (zone verte)
â†’ Slide 4 : Zoom sur les 4 tables de ressources (zone orange)
â†’ Slide 5 : Zoom sur les relations (flÃ¨ches) et CASCADE DELETE
â†’ Slide 6 : Tableau rÃ©capitulatif des volumes (optionnel)


ğŸ¤ TRANSITIONS FLUIDES
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"Maintenant qu'on a vu qui utilise l'application, voyons comment on enregistre les scans..."
"Une fois qu'un scan est crÃ©Ã©, oÃ¹ vont les ressources trouvÃ©es ? C'est lÃ  que..."
"Et pour garantir la cohÃ©rence, regardez ces relations..."


â“ ANTICIPER LES QUESTIONS DU JURY
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Q: "Pourquoi sÃ©parer les ressources et les performances ?"
R: "Parce qu'une ressource change rarement (instance_type, rÃ©gion), mais ses
    mÃ©triques changent toutes les 5 minutes. SÃ©parer Ã©vite la redondance et
    optimise les requÃªtes."

Q: "Comment vous gÃ©rez la suppression de donnÃ©es ?"
R: "Avec CASCADE DELETE sur les clÃ©s Ã©trangÃ¨res. Ã‡a garantit qu'on ne laisse
    jamais d'orphelins dans la base. Et cÃ´tÃ© application, avant de supprimer
    un utilisateur, on vÃ©rifie qu'il n'a pas de scans actifs."

Q: "Pourquoi MariaDB et pas PostgreSQL ?"
R: "MariaDB est plus que suffisant pour les besoins actuels et j'ai une bonne
    expÃ©rience dessus. Mais l'architecture est indÃ©pendante grÃ¢ce Ã  SQLAlchemy :
    on pourrait migrer vers PostgreSQL en changeant juste la connection string."

Q: "Comment vous gÃ©rez la croissance de la base ?"
R: "3 leviers : partitionnement par date (archiver l'ancien), index sur les
    colonnes frÃ©quemment requÃªtÃ©es, et rÃ©plication en lecture si besoin."

Q: "Est-ce vraiment multi-tenant sÃ©curisÃ© ?"
R: "Oui. Chaque requÃªte filtre par user_id, et l'ORM SQLAlchemy protÃ¨ge contre
    les injections SQL. Les tests d'intÃ©gration vÃ©rifient l'isolation."


â±ï¸ TIMING (AJUSTE SELON TON TEMPS TOTAL)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Version courte (3 min) : Vue d'ensemble + users + scan_runs + ressources (rapide) + Conclusion
Version moyenne (5 min) : Tout sauf "VolumÃ©trie" et "Technologie"
Version longue (7 min) : Tout + Questions/RÃ©ponses


ğŸ”¥ PHRASES CLÃ‰S Ã€ RETENIR
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"scan_runs, c'est comme un ticket de caisse : il enregistre ce qui a Ã©tÃ© fait"
"CASCADE DELETE garantit qu'on ne laisse jamais d'orphelins dans la base"
"Multi-tenant : impossible qu'une entreprise voie les donnÃ©es d'une autre"
"NormalisÃ©e 3NF : chaque info n'est stockÃ©e qu'une seule fois"
"L'ORM SQLAlchemy fait le pont entre le diagramme de classes et la base"


ğŸ’¡ ASTUCE PRO
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Si le jury est technique, insiste sur :
   â†’ La normalisation 3NF
   â†’ Les index et optimisations
   â†’ La gestion des transactions
   â†’ Les tests d'intÃ©gritÃ©

Si le jury est moins technique, insiste sur :
   â†’ La sÃ©curitÃ© multi-tenant
   â†’ L'historique des scans
   â†’ La scalabilitÃ©
   â†’ La facilitÃ© de maintenance


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    LIEN AVEC LE DIAGRAMME DE CLASSES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"Un dernier point important : ce diagramme de base de donnÃ©es et le diagramme
de classes qu'on a vu avant sont COMPLÃ‰MENTAIRES.

Le diagramme de classes montre COMMENT le code est organisÃ© (Factory, Abstract, AWS).
Le diagramme BDD montre OÃ™ les donnÃ©es sont stockÃ©es.

Et entre les deux ? L'ORM SQLAlchemy.

CloudScanner.save_to_db() â†’ INSERT dans ec2_instances
ScanRun.get_resources() â†’ SELECT avec JOIN

C'est une architecture en COUCHES :
   Couche 1 : API (FastAPI)
   Couche 2 : Business Logic (Scanners, Factories)
   Couche 3 : ORM (SQLAlchemy)
   Couche 4 : Base de donnÃ©es (MariaDB)

Chaque couche a sa responsabilitÃ©. Aucune ne fait le job d'une autre.
C'est le principe de SÃ©paration des ResponsabilitÃ©s."


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                    BON COURAGE ! ğŸš€
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
